'''A barebones command-line client to interface with the chat server.To run from the project root folder:     python client/client.py''''''A barebones command-line client to interface with the chat server.To run from the project root folder:     python client/client.py'''#==================================# IMPORTS# `request` is an object that represents the current request being handled, # allowing for the easy exchange of REST communicationimport requests# JSON encoding and decoding, used for communication with serverimport json# high-level Python threading library, used to poll for messages in the chat clientimport threading# module to provide current time and other time-related functionsimport time# thread synchronized queue class in python, for communicating between threadsfrom Queue import Queue# Server addressSERVER_IP = "http://localhost"SERVER_PORT = "5000"server_url = SERVER_IP + ":" + SERVER_PORT# OptionsCON_WIDTH = 70          # for right-aligning others' messages, chat widthPOLL_INTERVAL = 0.5     # frequency for polling server for new messages, in seconds# Without any login, logged_out will be False and username is a blank stringusername = ""logged_in = False# Console commands for message chat clientCOMMANDS = {    'help': (['help', 'h', '?'], 'Print all commands', []),    'login': (['login', 'l'], 'Log in', ['username']),    'logout': (['logout', 'q'], 'Log out', []),    'new-account': (['newaccount', 'na'], 'Create new account', ['username']),    'delete-account': (['delaccount', 'da'], 'Delete current account', []),    'new-group': (['newgroup', 'ng'], 'Create new chat group', ['groupname', 'user1', 'user2', '...']),    'chat-ind': (['chat', 'c'], 'Chat with user', ['username']),    'chat-group': (['chat', 'cg'], 'Chat with group', ['groupname']),    'list-users': (['listusers', 'lu'], 'List all users', []),    'search-users': (['searchusers', 'su'], 'Search for users by username', ['querystring']),    'list-groups': (['listgroups', 'lg'], 'List all groups', []),    'search-groups': (['searchgroups', 'sg'], 'Search for groups by groupname and included usernames', ['querystring']),    'exit': (['exit'], 'Exit application', []),}def help():    """ Display a useful help menu for the chat client.        Side effect: Prints out command description, followed by                     all versions of the command and its arguments    """    for cmd in sorted(COMMANDS.values()):        print cmd[1]        for c in cmd[0]:            print '  '.join([' ', c, ' '.join('[%s]' % arg for arg in cmd[2])])        print ''# Command handlersdef login(new_username):    """     Logs in user by making login request of server. On success, sets the         client-side username and logged_in variables. On failure, prints        error message from server.        Args:        new_username:            type - string            presuppositions - not the empty string        Effect:        Prints whether login is successful         Alters login state within client, and sends login request to server    """    global username    global logged_in    if logged_in:        print "You're already logged in as %s; please log out first!" % username    else:        r = requests.post(server_url + "/accounts/login", \            data = json.dumps({'username': new_username}))        if (r.status_code == 200):            username = new_username            logged_in = True            print "Successfully logged in as %s." % username        else:             parsed_json = json.loads(r.text)            message = parsed_json['message']            print "Error: %s" % messagedef create_account(new_username):    """    Creates new account for this chat client, making create request    of server. On error, prints the server's error message. Internallly    checks if user currently logged in and fails in that case.    Args:        new_username:        type - string        presuppositions - not the empty string    Effect:        Prints whether account creation is successful     """    if logged_in:        print "You can't create an account while logged in as another user."    else:         r = requests.post(server_url + "/accounts/create", \            data = json.dumps({'username': new_username}))        if r.status_code == 200:            print "Successfully created account \'%s\'." % new_username        else:            parsed_json = json.loads(r.text)            message = parsed_json['message']            print "Error: %s" % messagedef delete_account():    """    Deletes account from this chat client, making delete account request    of server. Changes internal login state.     On error, prints the server's error message. Internallly    checks if user not currently logged in and prints error in that case.    Prints whether account deletion is successful     """    global logged_in    global username    if not logged_in:        print "You can't delete your account when not logged in."    else:        r = requests.post(server_url + "/accounts/delete", \            data = json.dumps({'username': username}))        if r.status_code == 200:            print "Successfully deleted account \'%s\'." % username            username = ""            logged_in = False        else:            parsed_json = json.loads(r.text)            message = parsed_json['message']            print "Error: %s" % message            print "Failed to delete account. Please try again."def logout():    """    Logs out from this chat client, making logout request of server.    Checks if logges in, and prints error in that case.    Changes internal login state by modifying username and logged_in.    On error, prints server's error message.    Prints whether logout was successful.    """    global logged_in    global username    if not logged_in:        print "You're not logged in."    else:        r = requests.post(server_url + "/accounts/logout", \            data = json.dumps({'username': username}))        if r.status_code == 200:            print "Successfully logged out account \'%s\'." % username            username = ""            logged_in = False        else:            parsed_json = json.loads(r.text)            message = parsed_json['message']            print "Error: %s" % message            print "Failed to log out. Please try again."def create_group(groupname, users):    """    Creates user group, given a group name and list of users.    Will add the current user to the group if not included in the     users list; will check that the users list has at least 1 other user.    Makes request of server to create group, sending username,     groupname, and users list.     Prints success, or error code from server.    Args:        groupname:            type: string        users:            type: list of strings    """    global username    global logged_in    # errors    if not logged_in:        print "You must be logged in to create chat groups."        return     # add current user to user list, if necessary    if username not in users:        users.append(username)    # check on number of group members    if len(set(users)) < 2:        print "You must invite at least one other user to the group. </3"        return    data = {        'creator' : username,        'groupname' : groupname,        'usernames' : users    }    # server request    r = requests.post(server_url + "/groups/create", data = json.dumps(data))    if r.status_code == 200:        print "Successfully created group \'%s\'." % groupname    else:        parsed_json = json.loads(r.text)        message = parsed_json['message']        print "Error: %s" % messagedef ack(ids, room_name, do_group):    """    Acknowledge the receipt of messages by sending the    ack request to the server. Check for error and print if     server error encountered.    Args:         ids: Message ids seen            type: list of ints         room_name: name of chat room, either a                     single user or a group name            type: string        do_group: true if ack-ing group messages;                   false if ack-ing ind messages            type: boolean    """    data = {        "viewer" : username,        "room_user" : None if do_group else room_name,        "room_group" : room_name if do_group else None,        "last_seen_id" : max(ids)    }    r = requests.post(server_url + '/messages/ack', data = json.dumps(data))    if r.status_code != 200:        parsed_json = json.loads(r.text)        message = parsed_json['message']        print "Error: %s" % messagedef fetch_undelivered_messages(from_name, do_group):    """        Retrieve messages that haven't been delivered to this         user yet, either from a group chat or individual chat.        Checks for server error and prints appropriate message.        Args:            from_name: name of the ind or group whose                        messages we wish to receive                type: string            do_group: true if we want to receive a group's                        messages, false if we are looking for an                        individual's messages                type: boolean        Return:             (list of messages, list of authors of those messages)            These two lists will have the same length, such that            the ith message is written by the ith author (in the case            of group messages). For individual messages, all messages            must be from from_name.            type: on success -                     if do_group - (list of strings, list of strings)                    else - (list of strings, None)                  on server failure - None    """    # looking for messages to current user from the from_name user    data = {        'to' : username,        'from' : from_name    }    # make server request to fetch-undelivered endpoint for ind    # make server request to fetch-undelivered-group endpoint for group    fetch_str = 'fetch-undelivered'    if (do_group):        fetch_str += '-group'    r = requests.post(server_url + '/messages/' + fetch_str, \        data = json.dumps(data))    # server error    if r.status_code != 200:        parsed_json = json.loads(r.text)        message = parsed_json['message']        print "Error: %s" % message        return None    else:        parsed_json = json.loads(r.text)        # ids will help us let the server know which messages we         # have successfully received        ids = parsed_json['ids']        if (len(ids) > 0):            # acknowledge successful receipt of messages            ack(ids, from_name, do_group)        senders = None        if (do_group):            senders = parsed_json['authors']        return (parsed_json['messages'], senders)# Return True if message was successfully sentdef send_message(to_name, do_group, message):    """    Sends message to the chatroom to_name, which can be an     individual or group depending on do_group.     If server indicates that message failed to send, allows     users to retry by pressing 'y', which will resend the request     to the server.    Args:        to_name: Name of the chatroom that will receive our message            type: string        do_group: true if we wish to talk to a group, false otherwise            type: boolean        message: our message to to_name            type: string    Return: True on success, False otherwise        type: bool    """    data = {        'to': to_name,        'sender': username,        'message': message    }    # request either send or send-group depending on do_group    send_str = 'send'    if (do_group):        send_str += '-group'    r = requests.post(server_url + '/messages/' + send_str, \        data = json.dumps(data))    # server error    if r.status_code != 200:        parsed_json = json.loads(r.text)        error_message = parsed_json['message']        print "Error: %s" % error_message        # return false if invalid parameters were given        if r.status_code == 400:            return False        # allow user to retry sending well-formed requests        print "Message failed to send: " + message        retry_str = raw_input("Type y to resend: ")        if (retry_str == "y"):            return send_message(to_name, do_group, message)    return Truedef print_matching_users(query):    """    Search for users matching a query which can have wildcards.    On server failure, prints error message.    Otherwise, prints all users found into the chat client.    Args:         query: Username to be searched for, including wildcards                to search for usernames by simple patterns.            type: string    """    r = requests.post(server_url + "/accounts/search", \        data = json.dumps({'query': query}))    # server error    if r.status_code != 200:        parsed_json = json.loads(r.text)        error_message = parsed_json['message']        print "Error: %s" % error_message    else:         parsed_json = json.loads(r.text)        results = parsed_json['accounts']        # print found users        print 'Found %d result(s).' % len(results)        for username in results:            print '  %s' % usernamedef print_all_users():    """    Print all users in system using a wildcard search.    """    print_matching_users("*")def print_matching_groups(query):    """    Search for groups matching a query which can have wildcards.    Groups may match by either group name or user names within the    group. These matches are printed separately.    On server failure, prints error message.    Args:         query: Groupname to be searched for, including wildcards                to search for groupname by simple patterns on                 groupname or the users in a group.            type: string    """    # server request    r = requests.post(server_url + "/groups/search", \        data = json.dumps({'query': query}))    # server error    if r.status_code != 200:        parsed_json = json.loads(r.text)        error_message = parsed_json['message']        print "Error: %s" % error_message    else:        parsed_json = json.loads(r.text)                results_by_groupname = parsed_json['groups_by_groupname']        results_by_username = parsed_json['groups_by_username']        if not (results_by_groupname or results_by_username):            print 'No groups match this query.'            return         # group names matching wildcard query        if results_by_groupname:            print 'Found %d group(s) with matching groupnames.' % len(results_by_groupname)            for groupname in results_by_groupname:                print '  %s' % groupname        # user names matching wildcard query        if results_by_username:            print 'Found %d group(s) containing matching username(s).' % len(results_by_username)            for groupname in results_by_username:                print '  %s' % groupnamedef print_all_groups():     """    Print all groups in system using a wildcard search.    """    print_matching_groups('*')class PollMessages(threading.Thread):    # Background daemon for polling for new messages while in a chat room.    def __init__(self, data):        """        Initialize thread and save data provided to the constructor.        """        threading.Thread.__init__(self)        self.data = data    def run(self):        """        Poll for new messages periodically.        Signaling between main thread and this daemon is handled with two        queues, q and p.        p: On server failure, used to signal to the main thread that             fetching is done.        q: Used to quit when receiving signal from main thread to quit.        """        do_group = self.data["do_group"]        name = self.data["name"]        q = self.data["q"]        p = self.data["p"]        # proceed while main thread is not signaling to stop        while(q.empty()):            resp = fetch_undelivered_messages(name, do_group)            if not resp:                p.put(1)                break            # print messages in chat room            (messages, senders) = resp            sender = name            if (len(messages) > 0):                # if individual chat, preceed messages with ind's name                if (senders == None):                    print ("\n[%s]" % name).rjust(CON_WIDTH)                for i in range(0, len(messages)):                    # logic below used to print the correct sender in a                     # group chat.                    if ((senders != None) and \                      ((i == 0) or \                        (senders[i-1] != senders[i]))):                        print ("%s:" % senders[i]).rjust(CON_WIDTH)                    print messages[i].rjust(CON_WIDTH)            # sleep briefly before polling for more messages            time.sleep(POLL_INTERVAL)        q.get()        returndef chat(name, do_group):    """    Launch chatroom with either an individual or a group.    Launch another thread to poll for/ display incoming messages.    Repeatedly wait for next user input. When the user types    the EXIT_CHAT string, :q, leave the chatroom and quit the     daemon thread.    Args:        name: name of the individual or group the user wishes                to chat with            type: string        do_group: true if looking to chat with a group, false if                    looking to chat with an individual            type: boolean    """    if not logged_in:        print "You must be logged in to chat."        return    # string used as signal from user to exit chatroom    EXIT_CHAT = ":q"    print '========================================='    print 'Chat with %s' % name    print '========================================='    quit = False    print "Type %s to leave chat." % EXIT_CHAT    data = {        "name": name,        "do_group": do_group,        "q" : Queue(), # place data in here to kill the polling thread        "p" : Queue(), # place data in here to kill the user-input thread (this)    }    # Spin up background daemon to poll server for new messages    t = PollMessages(data)    t.daemon = True    t.setDaemon(True)    t.start()    time.sleep(1)    # while server error hasn't occurred     while data["p"].empty() and not quit:        send_str = raw_input("")        if (send_str == EXIT_CHAT):            quit = True        else:             # Die if the other user has deleted their account, or            # if sending message request otherwise malformed.            quit = not send_message(name, do_group, send_str)    # signal to daemon that we have quit    data["q"].put(1)    t.join()    print '========================================='## MENUdef parse_command(command_arr):    """    Parse user command and call the appropriate function above.    Prints error message if an incorrect number of arguments    was entered for a rule, or if the rule was not recognized.    Args:         command_arr: represents the command and all arguments                    which the user has just typed            type: array of strings    """    incorrect_str = "Incorrect argument count."    # help    if (command_arr[0] in COMMANDS['help'][0]):        if (len(command_arr) != len(COMMANDS['help'][2]) + 1):            print incorrect_str        else:            help()    # login    elif (command_arr[0] in COMMANDS['login'][0]):        if (len(command_arr) != len(COMMANDS['login'][2]) + 1):            print incorrect_str        else:            login(command_arr[1])    # logout    elif (command_arr[0] in COMMANDS['logout'][0]):        if (len(command_arr) != len(COMMANDS['logout'][2]) + 1):            print incorrect_str        else:            logout()    # make new account    elif (command_arr[0] in COMMANDS['new-account'][0]):        if (len(command_arr) != len(COMMANDS['new-account'][2]) + 1):            print incorrect_str        else:            create_account(command_arr[1])    # delete account    elif (command_arr[0] in COMMANDS['delete-account'][0]):        if (len(command_arr) != len(COMMANDS['delete-account'][2]) + 1):            print incorrect_str        else:            delete_account()    # make a new group    elif (command_arr[0] in COMMANDS['new-group'][0]):        if (len(command_arr) < 3):            # expected arguments: groupname name1 name2 ...            # so, at least one other person in group            print incorrect_str        else:            create_group(command_arr[1], command_arr[2:])    # list all users    elif (command_arr[0] in COMMANDS['list-users'][0]):        if (len(command_arr) != len(COMMANDS['list-users'][2]) + 1):            print incorrect_str        else:            print_all_users()    # search users with a query string    elif (command_arr[0] in COMMANDS['search-users'][0]):        if (len(command_arr) != len(COMMANDS['search-users'][2]) + 1):            print incorrect_str        else:            print_matching_users(command_arr[1])    # list all groups    elif (command_arr[0] in COMMANDS['list-groups'][0]):        if (len(command_arr) != len(COMMANDS['list-groups'][2]) + 1):            print incorrect_str        else:            print_all_groups()    # search groups with a query string    elif (command_arr[0] in COMMANDS['search-groups'][0]):        if (len(command_arr) != len(COMMANDS['search-groups'][2]) + 1):            print incorrect_str        else:            print_matching_groups(command_arr[1])    # chat an individual    elif (command_arr[0] in COMMANDS['chat-ind'][0]):        if (len(command_arr) != len(COMMANDS['chat-ind'][2]) + 1):            print incorrect_str        else:            chat(command_arr[1], False)    # chat a group    elif (command_arr[0] in COMMANDS['chat-group'][0]):        if (len(command_arr) != len(COMMANDS['chat-group'][2]) + 1):            print incorrect_str        else:            chat(command_arr[1], True)    # leave the chat client    elif (command_arr[0] in COMMANDS['exit'][0]):        if (len(command_arr) != len(COMMANDS['exit'][2]) + 1):            print incorrect_str        else:            return False    else:         print "What?"    return True#==================================# MAINif __name__ == '__main__':    '''        Loop, accepting and executing commands from input,         until the user quits out.    '''        print "To see available commands, type \'help\'.\n"    loop = True    while loop:        if logged_in:            command_str = "%s > " % username        else:            command_str = "[not logged in] > "        command = raw_input(command_str)        command_arr = command.split()        loop = parse_command(command_arr)